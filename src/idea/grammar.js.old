import {lexer} from '../moo'

export const bibtexGrammar = new Grammar({
  Main () {
    let possible = true
    let entries = []

    while (possible) {
      try {
        entries.push(this.match(['Entry']))
      } catch (err) {
        if (err.message.includes('end of input')) {
          possible = false
        } else {
          throw err
        }
      }
    }

    return entries
  },

  Entry () {
    this.consume('at')
    this.consume('spaceHor', true)

    let type = this.consume('entryTypeRef')

    this.consume('spaceHor', true)

    let endingChar
    if (this.consume('lbracket', true)) {
      endingChar = 'rbracket'
    } else if (this.consume('lparen', true)) {
      endingChar = 'rparen'
    } else {
      // trigger error
      this.consume('lbracket')
    }

    this.consume('whitespace', true)

    let label = this.consume('identifier')

    this.consume('whitespace', true)
    this.consume('comma')
    this.consume('whitespace', true)

    let properties = this.match(['EntryBody'])

    this.consume(endingChar)
    this.consume('comma', true)

    return {type, label, properties}
  },

  EntryBody () {
    this.consume('whitespace', true)

    let properties = {}

    let possible = true
    while (possible) {
      try {
        let field = this.consume('')

        this.consume('whitespace', true)
        this.consume('equals')
        this.consume('whitespace', true)

        let value = +this.consume('number', true) || this.match('Expression')

        this.consume('whitespace', true)
        this.consume('comma')

        properties[field] = value
      } catch (e) {
        possible = false
      }
    }

    return properties
  },

  Expression () {
    let output = this.match(['QuoteString', 'BracketString'])

    let possible = true
    while (possible) {
      try {
        this.consume('whitespace', true)
        this.consume('hashtag')
        this.consume('whitespace', true)
        output += this.match(['QuoteString', 'BracketString'])
      } catch (err) {
        possible = false
      }
    }

    return output
  },

  QuoteString () {
    this.consume('quote')

  }
})

export function bibtex (text) {
  return bibtexGrammar.parse(lexer.reset(text))
}

export class Grammar {
  constructor (rules) {
    this.tokens = []

    this.rules = rules
    this.mainRule = Object.keys(rules)[0]
  }

  parse (iterator) {
    this.tokens = Array.from(iterator)
    this.lexer = iterator
    this.index = 0
    return this.match(this.mainRule)
  }

  matchToken (type) {
    return type === this.tokens[this.index].type
  }

  matchAnyToken (types) {
    return types.some(type => type === this.tokens[this.index].type)
  }

  matchTokens (types) {
    return types.every((type, i) => type === this.tokens[this.index + i])
  }

  consumeToken (type, {optional} = {}) {
    let token = this.tokens[this.index]

    if (token.type === type) {
      this.index++
      return token
    } else if (optional) {
      return undefined
    } else {
      this.lexer.formatError(token, `expected "${type}", got "${token.type}"`)
    }
  }

  consumeAnyToken (types) {
    let token = this.tokens[this.index]

    if (types.includes(token.type)) {
      this.index++
      return token
    } else
  }

  handleTokenError (type, token, optional) {
    if (optional) {
      return undefined
    } else {
      this.lexer.formatError(token, `expected "${type}", got "${token.type}"`)
    }
  }

  match (rule, {optional, repeat} = {}) {
    let error
    for (let rule of rules) {
      try {
        let value = this.rules[rule].call(this)
        return value
      } catch (err) {
        error = e
      }
    }

    throw error
  }

  matchAny (rules, {optional, repeat} = {}) {

  }

  matchPattern () {

  }

  consume (type, optional) {
    if (!this.nextToken) {
      let {done, value} = this.tokens.next()
      if (done) {
        throw new Error(this.tokens.formatError(value, 'end of input'))
      }
      this.nextToken = value
    }

    if (this.nextToken.type === type) {
      let token = this.nextToken
      delete this.nextToken
      return token
    } else if (!optional) {
      throw new Error(this.tokens.formatError(this.nextToken, ))
    }
  }
}
